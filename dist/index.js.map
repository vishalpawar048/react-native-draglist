{"version":3,"file":"index.js","sources":["../node_modules/babel-plugin-transform-async-to-promises/helpers.mjs","../src/DragListContext.tsx","../src/index.tsx"],"sourcesContent":["// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[_asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, result);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\tvar result = _entry(_this);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tresult.then(returnValue, function(error) {\n\t\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturnValue(result);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","// Much of this comes from concepts in https://github.com/computerjazz/react-native-draggable-flatlist/blob/main/src/context/draggableFlatListContext.tsx\nimport React, { useContext, useMemo } from \"react\";\nimport { Animated } from \"react-native\";\n\n// Tracks the position and extent (width or height) in an axis-independent way\n// (i.e. if horizontal, then pos is an x and extent is a width).\nexport interface PosExtent {\n  pos: number; // The x or y position\n  extent: number; // The width or height\n}\n\n// A map of each item's layout rectangle, used to calculate how much space to\n// make for an item being dragged.\nexport interface LayoutCache {\n  [key: string]: PosExtent;\n}\n\nexport interface ActiveData {\n  key: string;\n  index: number;\n}\n\n// This all basically enables us to pass data into a CellRendererComponent,\n// which we otherwise don't control the props to.\ntype ContextProps<T> = {\n  activeData: ActiveData | null;\n  keyExtractor: (item: T, index: number) => string;\n  pan: Animated.Value;\n  panIndex: number;\n  layouts: LayoutCache;\n  horizontal: boolean | null | undefined;\n  children: React.ReactNode;\n  dataGen: number;\n};\n\ntype DragListContextValue<T> = Omit<ContextProps<T>, \"children\">;\n\nconst DragListContext = React.createContext<\n  DragListContextValue<any> | undefined\n>(undefined);\n\nexport function DragListProvider<T>({\n  activeData,\n  keyExtractor,\n  pan,\n  panIndex,\n  layouts,\n  horizontal,\n  children,\n  dataGen,\n}: ContextProps<T>) {\n  const value = useMemo(\n    () => ({\n      activeData,\n      keyExtractor,\n      pan,\n      panIndex,\n      layouts,\n      horizontal,\n      dataGen,\n    }),\n    [activeData, keyExtractor, pan, panIndex, layouts, horizontal, dataGen]\n  );\n\n  return (\n    <DragListContext.Provider value={value}>\n      {children}\n    </DragListContext.Provider>\n  );\n}\n\nexport function useDragListContext<T>() {\n  const value = useContext(DragListContext);\n  if (!value) {\n    throw new Error(\n      \"useDragListContext must be called within DragListProvider\"\n    );\n  }\n  return value as DragListContextValue<T>;\n}\n","import React, {\n  useCallback,\n  useEffect,\n  useLayoutEffect,\n  useMemo,\n  useRef,\n  useState,\n} from \"react\";\nimport {\n  Animated,\n  Easing,\n  FlatList,\n  FlatListProps,\n  GestureResponderEvent,\n  LayoutChangeEvent,\n  ListRenderItemInfo,\n  NativeScrollEvent,\n  NativeSyntheticEvent,\n  PanResponder,\n  PanResponderGestureState,\n  Platform,\n  StyleProp,\n  View,\n  ViewStyle,\n} from \"react-native\";\nimport {\n  ActiveData,\n  DragListProvider,\n  LayoutCache,\n  PosExtent,\n  useDragListContext,\n} from \"./DragListContext\";\n\n// Each renderItem call is given this when rendering a DragList\nexport interface DragListRenderItemInfo<T> extends ListRenderItemInfo<T> {\n  /**\n   * Call this function whenever you detect a drag motion starting.\n   */\n  onDragStart: () => void;\n\n  /**\n   * Call this function whenever a drag motion ends (e.g. onPressOut)\n   */\n  onDragEnd: () => void;\n\n  /**\n   * @deprecated Use onDragStart instead\n   * @see onDragStart\n   */\n  onStartDrag: () => void;\n\n  /**\n   * @deprecated Use onDragEnd instead\n   * @see onDragEnd\n   */\n  onEndDrag: () => void;\n\n  /**\n   * Whether the item is being dragged at the moment.\n   */\n  isActive: boolean;\n}\n\n// Used merely to trigger FlatList to re-render when necessary. Changing the\n// activeKey or the panIndex should both trigger re-render.\ninterface ExtraData {\n  activeKey: string | null;\n  panIndex: number;\n  // Used only to assure WDYR that we're intentionally re-rendering with a \"different\" object\n  detritus?: string;\n}\n\ninterface Props<T> extends Omit<FlatListProps<T>, \"renderItem\"> {\n  data: T[];\n  keyExtractor: (item: T, index: number) => string;\n  renderItem: (info: DragListRenderItemInfo<T>) => React.ReactElement | null;\n  containerStyle?: StyleProp<ViewStyle>;\n  onDragBegin?: () => void;\n  onDragEnd?: () => void;\n  onHoverChanged?: (hoverIndex: number) => Promise<void> | void;\n  onReordered?: (fromIndex: number, toIndex: number) => Promise<void> | void;\n  onScroll?: (event: NativeSyntheticEvent<NativeScrollEvent>) => void;\n  onLayout?: (e: LayoutChangeEvent) => void;\n  CustomFlatList?: typeof FlatList;\n}\n\nfunction DragListImpl<T>(\n  props: Props<T>,\n  ref?: React.ForwardedRef<FlatList<T> | null>\n) {\n  const {\n    containerStyle,\n    data,\n    keyExtractor,\n    onDragBegin,\n    onDragEnd,\n    onScroll,\n    onLayout,\n    renderItem,\n    CustomFlatList = FlatList,\n    ...rest\n  } = props;\n  // activeKey and activeIndex track the item being dragged\n  const activeDataRef = useRef<ActiveData | null>(null);\n  const isReorderingRef = useRef(false); // Whether we're actively rendering a reorder right now.\n  // panIndex tracks the location where the dragged item would go if dropped\n  const panIndex = useRef(-1);\n  const [extra, setExtra] = useState<ExtraData>({\n    activeKey: activeDataRef.current?.key ?? null,\n    panIndex: -1,\n  });\n  const layouts = useRef<LayoutCache>({}).current;\n  const panGrantedRef = useRef(false);\n  const grantScrollPosRef = useRef(0); // Scroll pos when granted\n  // The amount you need to add to the touched position to get to the active\n  // item's center.\n  const grantActiveCenterOffsetRef = useRef(0);\n  const autoScrollTimerRef = useRef<ReturnType<typeof setInterval> | null>(\n    null\n  );\n\n  // #78 - keep onHoverChanged up to date in our ref\n  const hoverRef = useRef(props.onHoverChanged);\n  hoverRef.current = props.onHoverChanged;\n  const reorderRef = useRef(props.onReordered);\n  reorderRef.current = props.onReordered;\n  const keyExtractorRef = useRef(keyExtractor);\n  keyExtractorRef.current = keyExtractor;\n\n  const dataRef = useRef(data);\n  dataRef.current = data;\n\n  // In order to sync our animations with when the parent changes `data` on us, we render in\n  // \"generations\". Whenever the parent-provided data changes, we bump the generation.\n  const lastDataRef = useRef(data);\n  const dataGenRef = useRef(0);\n\n  const flatRef = useRef<FlatList<T> | null>(null);\n  const flatWrapRef = useRef<View>(null);\n  const flatWrapLayout = useRef<PosExtent>({\n    pos: 0,\n    extent: 1,\n  });\n  const flatWrapRefPosUpdatedRef = useRef(false);\n  const scrollPos = useRef(0);\n\n  // pan is the drag dy\n  const pan = useRef(new Animated.Value(0)).current;\n  const setPan = useCallback(\n    (value: number) => {\n      // Starting RN 0.76.3, pan.setValue(whatever) no longer animates the isActive item. Dunno whether\n      // it's the useNativeDriver or what that gets this working again. So, lamely, we set the value\n      // using a zero-duration Animated.timing.\n      Animated.timing(pan, {\n        duration: 0,\n        toValue: value,\n        useNativeDriver: true,\n      }).start();\n    },\n    [pan]\n  );\n\n  const shouldCapturePan = useCallback(() => {\n    return !!activeDataRef.current && !isReorderingRef.current;\n  }, []);\n\n  const onPanResponderGrant = useCallback(\n    (_: GestureResponderEvent, gestate: PanResponderGestureState) => {\n      grantScrollPosRef.current = scrollPos.current;\n      setPan(0);\n      panGrantedRef.current = true;\n      flatWrapRefPosUpdatedRef.current = false;\n      flatWrapRef.current?.measure((_x, _y, _width, _height, pageX, pageY) => {\n        // Capture the latest y position upon starting a drag, because the\n        // window could have moved since we last measured. Remember that moves\n        // without resizes _don't_ generate onLayout, so we need to actively\n        // measure here. React doesn't give a way to subscribe to move events.\n        // We don't overwrite width/height from this measurement because\n        // height can come back 0.\n        flatWrapLayout.current = {\n          ...flatWrapLayout.current,\n          pos: props.horizontal ? pageX : pageY,\n        };\n        if (\n          activeDataRef.current &&\n          layouts.hasOwnProperty(activeDataRef.current.key)\n        ) {\n          const itemLayout = layouts[activeDataRef.current.key];\n          const screenPos = props.horizontal ? gestate.x0 : gestate.y0;\n          const clientViewPos = screenPos - flatWrapLayout.current.pos;\n          const clientPos = clientViewPos + scrollPos.current;\n          const posOnActiveItem = clientPos - itemLayout.pos;\n\n          grantActiveCenterOffsetRef.current =\n            itemLayout.extent / 2 - posOnActiveItem;\n        } else {\n          grantActiveCenterOffsetRef.current = 0;\n        }\n\n        flatWrapRefPosUpdatedRef.current = true;\n      });\n\n      onDragBegin?.();\n    },\n    []\n  );\n\n  const onPanResponderMove = useCallback(\n    (_: GestureResponderEvent, gestate: PanResponderGestureState) => {\n      clearAutoScrollTimer();\n\n      if (\n        !flatWrapRefPosUpdatedRef.current ||\n        !activeDataRef.current ||\n        !layouts.hasOwnProperty(activeDataRef.current.key)\n      ) {\n        return;\n      }\n\n      const posOrigin = props.horizontal ? gestate.x0 : gestate.y0;\n      const pos = props.horizontal ? gestate.dx : gestate.dy;\n      const wrapPos = posOrigin + pos - flatWrapLayout.current.pos;\n\n      function updateRendering() {\n        const movedAmount = props.horizontal ? gestate.dx : gestate.dy;\n        const panAmount =\n          scrollPos.current - grantScrollPosRef.current + movedAmount;\n\n        setPan(panAmount);\n\n        // Now we figure out what your panIndex should be based on everyone's\n        // heights, starting from the first element. Note that we can't do\n        // this math if any element up to your drag point hasn't been measured\n        // yet. I don't think that should ever happen, but take note.\n        const clientPos = wrapPos + scrollPos.current;\n        let curIndex = 0;\n        let key;\n        while (\n          curIndex < dataRef.current.length &&\n          layouts.hasOwnProperty(\n            (key = keyExtractorRef.current(dataRef.current[curIndex], curIndex))\n          ) &&\n          layouts[key].pos + layouts[key].extent <\n            clientPos + grantActiveCenterOffsetRef.current\n        ) {\n          curIndex++;\n        }\n\n        // This simply exists to trigger a re-render.\n        if (panIndex.current != curIndex) {\n          setExtra({ ...extra, panIndex: curIndex });\n          hoverRef.current?.(curIndex);\n          panIndex.current = curIndex;\n        }\n      }\n\n      const dragItemExtent = layouts[activeDataRef.current.key].extent;\n      const leadingEdge = wrapPos - dragItemExtent / 2;\n      const trailingEdge = wrapPos + dragItemExtent / 2;\n      let offset = 0;\n\n      // We auto-scroll the FlatList a bit when you drag off the top or\n      // bottom edge (or right/left for horizontal ones). These calculations\n      // can be a bit finnicky. You need to consider client coordinates and\n      // coordinates relative to the screen.\n      if (leadingEdge < 0) {\n        offset = -dragItemExtent;\n      } else if (trailingEdge > flatWrapLayout.current.extent) {\n        offset = dragItemExtent;\n      }\n\n      if (offset !== 0) {\n        function scrollOnce(distance: number) {\n          flatRef.current?.scrollToOffset({\n            animated: true,\n            offset: Math.max(0, scrollPos.current + distance),\n          });\n          updateRendering();\n        }\n\n        scrollOnce(offset);\n        autoScrollTimerRef.current = setInterval(() => {\n          scrollOnce(offset);\n        }, AUTO_SCROLL_MILLIS);\n      } else {\n        updateRendering();\n      }\n    },\n    []\n  );\n\n  const onPanResponderRelease = useCallback(\n    async (_: GestureResponderEvent, _gestate: PanResponderGestureState) => {\n      const activeIndex = activeDataRef.current?.index;\n\n      clearAutoScrollTimer();\n      onDragEnd?.();\n\n      if (\n        activeIndex != null && // Being paranoid, we exclude both undefined and null here\n        activeIndex !== panIndex.current &&\n        // Ignore the case where you drag the last item beyond the end\n        !(\n          activeIndex === dataRef.current.length - 1 &&\n          panIndex.current > activeIndex\n        )\n      ) {\n        try {\n          // We serialize reordering so that we don't capture any new pan\n          // attempts during this time. Otherwise, onReordered could be called\n          // with indices that would be stale if you panned several times\n          // quickly (e.g. if onReordered deletes an item, the next\n          // onReordered call would be made on a list whose indices are\n          // stale).\n          isReorderingRef.current = true;\n\n          await reorderRef.current?.(activeIndex, panIndex.current);\n        } finally {\n          isReorderingRef.current = false;\n        }\n      } else {\n        // #76 - Only reset here if we're not going to reorder the list. If we are instead\n        // reordering the list, we reset once the parent updates data. Otherwise things will jump\n        // around visually.\n        reset();\n      }\n    },\n    []\n  );\n\n  const panResponder = useRef(\n    PanResponder.create({\n      onStartShouldSetPanResponderCapture: shouldCapturePan,\n      onStartShouldSetPanResponder: shouldCapturePan,\n      onMoveShouldSetPanResponder: shouldCapturePan,\n      onMoveShouldSetPanResponderCapture: shouldCapturePan,\n      onPanResponderGrant,\n      onPanResponderMove,\n      onPanResponderRelease,\n    })\n  ).current;\n\n  const clearAutoScrollTimer = useCallback(() => {\n    if (autoScrollTimerRef.current) {\n      clearInterval(autoScrollTimerRef.current);\n      autoScrollTimerRef.current = null;\n    }\n  }, []);\n\n  /**\n   * When you don't want to trigger a re-render, pass false so we don't setExtra.\n   */\n  const reset = useCallback((shouldSetExtra = true) => {\n    activeDataRef.current = null;\n    panIndex.current = -1;\n    // setPan(0); Deliberately not handled here in render path, but in useLayoutEffect\n    if (shouldSetExtra) {\n      setExtra({\n        // Trigger re-render\n        activeKey: null,\n        panIndex: -1,\n        detritus: Math.random().toString(),\n      });\n    }\n    panGrantedRef.current = false;\n    grantActiveCenterOffsetRef.current = 0;\n    clearAutoScrollTimer();\n  }, []);\n\n  // Whenever new content arrives, we bump the generation number so stale animations don't continue\n  // to apply.\n  if (lastDataRef.current !== data) {\n    lastDataRef.current = data;\n    dataGenRef.current++;\n    reset(false); // Don't trigger re-render because we're already rendering.\n  }\n\n  // For reasons unclear to me, you need this useLayoutEffect here -- _even if you have an empty\n  // function body_. That's right. Having it here changes timings or something in React Native so\n  // our rendering is reset correctly, even if you do absolutely nothing in the function. As it\n  // stands, we need to reset the pan, so it's all good.\n  useLayoutEffect(() => {\n    setPan(0);\n  }, [data]);\n\n  const renderDragItem = useCallback(\n    (info: ListRenderItemInfo<T>) => {\n      const key = keyExtractorRef.current(info.item, info.index);\n      const isActive = key === activeDataRef.current?.key;\n      const onDragStart = () => {\n        // We don't allow dragging for lists less than 2 elements\n        if (data.length > 1) {\n          activeDataRef.current = { index: info.index, key: key };\n          panIndex.current = info.index;\n          setExtra({ activeKey: key, panIndex: info.index });\n        }\n      };\n      const onDragEnd = () => {\n        // You can sometimes have started a drag and yet not captured the\n        // pan (because you don't capture the responder during onStart but\n        // do during onMove, and yet the user hasn't moved). In those cases,\n        // you need to reset everything so that items become !isActive.\n        // In cases where you DID capture the pan, this function is a no-op\n        // because we'll end the drag when it really ends (since we've\n        // captured it). This all is necessary because the way the user\n        // decided to call onStartDrag is likely in response to an onPressIn,\n        // which then triggers on onPressOut the moment we capture (thus\n        // leading to a premature call to onEndDrag here).\n        if (activeDataRef.current && !panGrantedRef.current) {\n          reset();\n        }\n      };\n\n      return props.renderItem({\n        ...info,\n        onDragStart,\n        onStartDrag: onDragStart,\n        onDragEnd,\n        onEndDrag: onDragEnd,\n        isActive,\n      });\n    },\n    [props.renderItem, data.length]\n  );\n\n  const onDragScroll = useCallback(\n    (event: NativeSyntheticEvent<NativeScrollEvent>) => {\n      scrollPos.current = props.horizontal\n        ? event.nativeEvent.contentOffset.x\n        : event.nativeEvent.contentOffset.y;\n      if (onScroll) {\n        onScroll(event);\n      }\n    },\n    [onScroll]\n  );\n\n  const onDragLayout = useCallback(\n    (evt: LayoutChangeEvent) => {\n      flatWrapRef.current?.measure((_x, _y, width, height, pageX, pageY) => {\n        // Even though we capture x/y during onPanResponderGrant, we still\n        // capture height here because measureInWindow can return 0 height.\n        flatWrapLayout.current = props.horizontal\n          ? { pos: pageX, extent: width }\n          : { pos: pageY, extent: height };\n      });\n      if (onLayout) {\n        onLayout(evt);\n      }\n    },\n    [onLayout]\n  );\n\n  return (\n    <DragListProvider\n      activeData={activeDataRef.current}\n      keyExtractor={keyExtractorRef.current}\n      pan={pan}\n      panIndex={panIndex.current}\n      layouts={layouts}\n      horizontal={props.horizontal}\n      dataGen={dataGenRef.current}\n    >\n      <View\n        ref={flatWrapRef}\n        style={containerStyle}\n        {...panResponder.panHandlers}\n        onLayout={onDragLayout}\n      >\n        <CustomFlatList\n          ref={r => {\n            flatRef.current = r;\n            if (!!ref) {\n              if (typeof ref === \"function\") {\n                ref(r);\n              } else {\n                ref.current = r;\n              }\n            }\n          }}\n          data={data}\n          renderItem={renderDragItem}\n          CellRendererComponent={CellRendererComponent}\n          extraData={extra}\n          scrollEnabled={!activeDataRef.current}\n          onScroll={onDragScroll}\n          scrollEventThrottle={16} // From react-native-draggable-flatlist; no idea why.\n          removeClippedSubviews={false} // https://github.com/facebook/react-native/issues/18616\n          {...rest}\n        />\n      </View>\n    </DragListProvider>\n  );\n}\n\nconst SLIDE_MILLIS = 200;\nconst AUTO_SCROLL_MILLIS = 200;\nconst ANIM_VALUE_ZERO = new Animated.Value(0);\nconst ANIM_VALUE_ONE = new Animated.Value(1);\nconst ANIM_VALUE_NINER = new Animated.Value(999);\n\ntype CellRendererProps<T> = {\n  item: T;\n  index: number;\n  children: React.ReactNode;\n  onLayout?: (e: LayoutChangeEvent) => void;\n  style?: StyleProp<ViewStyle>;\n};\n\nfunction CellRendererComponent<T>(props: CellRendererProps<T>) {\n  const { item, index, children, onLayout, ...rest } = props;\n  const {\n    keyExtractor,\n    activeData,\n    pan,\n    panIndex,\n    layouts,\n    horizontal,\n    dataGen,\n  } = useDragListContext<T>();\n  const cellRef = useRef<View>(null);\n  const key = keyExtractor(item, index);\n  const isActive = key === activeData?.key;\n  const anim = useRef(new Animated.Value(0)).current;\n  // https://github.com/fivecar/react-native-draglist/issues/53\n  // Starting RN 0.76.3, we need to use Animated.Value instead of a plain number\n  // for Animated.View's elevation and zIndex. I (fivecar) don't understand why.\n  // If you use raw numbers, the elevation and zIndex don't have an effect.\n  const style = useMemo(() => {\n    return [\n      props.style,\n      isActive\n        ? {\n            elevation: ANIM_VALUE_ONE,\n            zIndex: ANIM_VALUE_NINER,\n            transform: [horizontal ? { translateX: pan } : { translateY: pan }],\n          }\n        : {\n            elevation: ANIM_VALUE_ZERO,\n            zIndex: ANIM_VALUE_ZERO,\n            transform: [\n              horizontal ? { translateX: anim } : { translateY: anim },\n            ],\n          },\n    ];\n  }, [props.style, isActive, horizontal, pan, anim]);\n  const onCellLayout = useCallback(\n    (evt: LayoutChangeEvent) => {\n      if (onLayout) {\n        onLayout(evt);\n      }\n\n      const layout = evt.nativeEvent.layout;\n      layouts[key] = horizontal\n        ? { pos: layout.x, extent: layout.width }\n        : { pos: layout.y, extent: layout.height };\n    },\n    [onLayout, horizontal, key, layouts]\n  );\n\n  useEffect(() => {\n    if (activeData != null) {\n      const activeKey = activeData.key;\n      const activeIndex = activeData.index;\n\n      if (!isActive && layouts.hasOwnProperty(activeKey)) {\n        if (index >= panIndex && index <= activeIndex) {\n          return Animated.timing(anim, {\n            duration: SLIDE_MILLIS,\n            easing: Easing.inOut(Easing.linear),\n            toValue: layouts[activeKey].extent,\n            useNativeDriver: true,\n          }).start();\n        } else if (index >= activeIndex && index <= panIndex) {\n          return Animated.timing(anim, {\n            duration: SLIDE_MILLIS,\n            easing: Easing.inOut(Easing.linear),\n            toValue: -layouts[activeKey].extent,\n            useNativeDriver: true,\n          }).start();\n        }\n      }\n    }\n    return Animated.timing(anim, {\n      duration: activeData?.key ? SLIDE_MILLIS : 0,\n      easing: Easing.inOut(Easing.linear),\n      toValue: 0,\n      useNativeDriver: true,\n    }).start();\n  }, [index, panIndex, activeData]);\n\n  // This resets our anim whenever a next generation of data arrives, so things are never translated\n  // to non-zero positions by the time we render new content.\n  useLayoutEffect(() => {\n    Animated.timing(anim, {\n      duration: 0,\n      toValue: 0,\n      useNativeDriver: true,\n    }).start();\n  }, [dataGen]); // Do not get rid of dataGen here - the whole point is to run when it changes.\n\n  if (Platform.OS == \"web\") {\n    // RN Web does not fire onLayout as expected\n    // Workaround for https://github.com/necolas/react-native-web/issues/2481\n    useEffect(() => {\n      cellRef.current?.measure((x, y, w, h) => {\n        layouts[key] = horizontal\n          ? { pos: x, extent: w }\n          : { pos: y, extent: h };\n      });\n    }, [index]);\n  }\n\n  return (\n    <Animated.View\n      {...rest}\n      style={style}\n      onLayout={onCellLayout}\n      ref={cellRef}\n      key={key}\n    >\n      {children}\n    </Animated.View>\n  );\n}\n\nconst DragList = React.forwardRef(DragListImpl) as <T>(\n  props: Props<T> & { ref?: React.ForwardedRef<FlatList<T>> }\n) => React.ReactElement;\n\nexport default DragList;\n"],"names":["DragListContext","React","createContext","undefined","DragListProvider","_ref","activeData","keyExtractor","pan","panIndex","layouts","horizontal","children","dataGen","value","useMemo","Provider","useDragListContext","useContext","Error","DragListImpl","props","ref","containerStyle","data","onDragBegin","onDragEnd","onScroll","onLayout","renderItem","_props$CustomFlatList","CustomFlatList","FlatList","rest","_objectWithoutPropertiesLoose","_excluded","activeDataRef","useRef","isReorderingRef","_useState","useState","activeKey","_activeDataRef$curren","_activeDataRef$curren2","current","key","extra","setExtra","panGrantedRef","grantScrollPosRef","grantActiveCenterOffsetRef","autoScrollTimerRef","hoverRef","onHoverChanged","reorderRef","onReordered","keyExtractorRef","dataRef","lastDataRef","dataGenRef","flatRef","flatWrapRef","flatWrapLayout","pos","extent","flatWrapRefPosUpdatedRef","scrollPos","Animated","Value","setPan","useCallback","timing","duration","toValue","useNativeDriver","start","shouldCapturePan","onPanResponderGrant","_","gestate","_flatWrapRef$current","measure","_x","_y","_width","_height","pageX","pageY","_extends","hasOwnProperty","itemLayout","screenPos","x0","y0","clientViewPos","clientPos","posOnActiveItem","onPanResponderMove","clearAutoScrollTimer","posOrigin","dx","dy","wrapPos","updateRendering","movedAmount","panAmount","curIndex","length","_hoverRef$current","call","dragItemExtent","leadingEdge","trailingEdge","offset","scrollOnce","distance","_flatRef$current","scrollToOffset","animated","Math","max","setInterval","AUTO_SCROLL_MILLIS","onPanResponderRelease","_gestate","activeIndex","_activeDataRef$curren3","index","_temp2","_temp","_finallyRethrows","_reorderRef$current","Promise","resolve","then","_wasThrown","_result","reset","e","reject","panResponder","PanResponder","create","onStartShouldSetPanResponderCapture","onStartShouldSetPanResponder","onMoveShouldSetPanResponder","onMoveShouldSetPanResponderCapture","clearInterval","shouldSetExtra","detritus","random","toString","useLayoutEffect","renderDragItem","info","item","isActive","_activeDataRef$curren4","onDragStart","onStartDrag","onEndDrag","onDragScroll","event","nativeEvent","contentOffset","x","y","onDragLayout","evt","_flatWrapRef$current2","width","height","View","style","panHandlers","r","CellRendererComponent","extraData","scrollEnabled","scrollEventThrottle","removeClippedSubviews","SLIDE_MILLIS","ANIM_VALUE_ZERO","ANIM_VALUE_ONE","ANIM_VALUE_NINER","_excluded2","_useDragListContext","cellRef","anim","elevation","zIndex","transform","translateX","translateY","onCellLayout","layout","useEffect","easing","Easing","inOut","linear","Platform","OS","_cellRef$current","w","h","DragList","forwardRef"],"mappings":"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"}